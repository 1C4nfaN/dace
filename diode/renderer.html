<html>

<head>
    <meta charset="utf-8" />
</head>

<body>
    <canvas id="myCanvas" width="1200" height="1200" style="border:1px solid #000000;"> </canvas>
    <script src="global_vars.js"></script> <!-- Global defines -->
    <script src="dagre.js"></script> <!-- Graph library -->
    <script src="renderer_util.js"></script> <!-- Offloaded display functions and classes -->
    <script src="sdfg_renderer.js"></script> <!-- Offloaded SDFG drawing functions -->
    <script src="datahelper.js"></script> <!-- Offloaded data analysis functions and classes -->
    <script src="Chart.bundle.min.js"></script> <!-- Library for charts -->
    <script src="lazy_fetch.js"></script>
    <!-- Offloaded button constructors -->
    <script src="parallelization_button.js"></script>
    <script src="memory_button.js"></script>
    <script src="vectorization_button.js"></script>
    <script src="cache_button.js"></script>
    <script src="memop_button.js"></script>

    <!-- Subwindow magic -->
    <script src="windowing.js"></script>

    <script>

        var socket = 0; // this is the websocket we use to communicate with the Python part
        var LINEHEIGHT = 10;

        var global_state = null;

        // This is a zoom function
        // To be called only by DIODE itself!
        window.zoom_func = scale => {
            console.log("Zooming");
            global_state.canvas_manager.scale(scale);
        };

        window.get_zoom = () => {
            return global_state.canvas_manager.getScale();
        };

        window.onerror = (msg, url, lineNo, colNo, error) => {
            if(error == null) {
                console.log("Error object was null.");
            }
            console.log("Error: " + msg + " in " + url.toString() + ":" + lineNo + ":" + colNo);
            console.log("Error occurred.\n" + error.message);
        }

        window.onload = function () {
            global_state = new SdfgState();
            global_state.setCtx(document.getElementById("myCanvas").getContext("2d"));
            socket = new WebSocket('ws://localhost:8023/');
            setInterval(x => socket.send(JSON.stringify({ "msg_type": "heartbeat" })), 100); // Set the heartbeat.
            socket.onopen = function (event) {
                socket.send(JSON.stringify({"msg_type": "info", "info": "client connected"}));
            }
            socket.onmessage = function (event) {
                message_handler(event.data);
            }
            socket.onclose = function (event) {
                console.log("Connection closed");
            }
            socket.onerror = function (event) {
                console.log("There was an error with the connection");
            }
            
        }

        document.getElementById("myCanvas").addEventListener('click', function(event) { 
            let x = event.pageX - document.getElementById("myCanvas").offsetLeft;
            let y = event.pageY - document.getElementById("myCanvas").offsetTop;
            
            if(window.get_zoom != undefined) {
                x /= window.get_zoom();
                y /= window.get_zoom();
            }

            clicked_elements = [];
            global_state.sdfg.nodes.forEach(function (state) {
                if (isWithinBB(x,y, state.attributes.layout)) {
                    let elem = {'type': state.attributes.type, 'id': state.id};
                    clicked_elements.push(elem);
                    state.attributes.nodes.forEach(function (node) {
                        if (isWithinBB(x,y, node.attributes.layout)) {
                            let elem = {'type': node.attributes.type, 'id': node.id};
                            clicked_elements.push(elem);
                        }
                    });
                }
            });
            socket.send(JSON.stringify({"msg_type": "click", "clicked_elements": clicked_elements}));
        });

        window.addEventListener('keypress', function(event) {
            ObjectHelper.logObject("Keypress event", event);
            console.log("Code was: " + event.code);
            console.log("Key was: " + event.key);
            if(event.key == "s") {
                let subpath = "perf_extracts/manual_";
                createImageDownload(global_state.brackets, subpath);
                alert("Image saved to " + subpath);
            }
        });

        class SdfgState {
            constructor() {
                this.ctx = null;
                this.sdfg = null;
                this.perfdata = null;
                this.perfdata_mode = {};
                this.graph = null;
                this.top_level_graph = null;
                this.state_graphs = {};
                this.canvas_manager = null;
                this.brackets = {};

                this.performance_references = {};

                this.target_memory_speed = 20.0;

                this.highlights = []; // List of tuples of stateid and nodeid to highlight.

                this.graphcache = {}; // Cache for the graphs

                this.communicator = new Communicator(socket);

                this.request_download = "";
            }


            setTargetMemBandwidth(target_bandwidth) {
                this.target_memory_speed = target_bandwidth;
            }
            defaultRun() {
                if(this.perfdataIsLazy()) {
                    // Return a lazy object
                    return new SuperSectionFetcher(this.communicator, this.perfdata.type, undefined, "meta:most_cores");
                }
                else {
                    return new SuperSectionFetcher(this.communicator, this.perfdata.type, this.perfdata.payload.find(x => x.runopts == "# ;export OMP_NUM_THREADS=4; Running in multirun config").data);
                }
            }
            
            getPerformanceReferences(id) {
                return this.performance_references[id];
            }

            setCtx(ctx) { this.ctx = ctx; this.canvas_manager = new CanvasDrawManager(ctx, this); this.canvas_manager.draw(); }
            setSDFG(sdfg) { this.sdfg = sdfg; this.graphcache = {}; }
            perfdataIsLazy() {
                return this.perfdata != null && this.perfdata.type == "DataReady";
            }
            setPerfData(pd) {
                if(pd.type == "DataReady") {
                    // Clear and set to lazy.
                    this.clearPerfData();
                    this.perfdata = pd;
                    this.perfdata_mode[pd.mode] = "avail";
                    
                    return;
                }
                let mode = pd.mode;
                if(mode == "default") 
                {
                    this.perfdata = null;
                    this.clearPerfData();
                }
                
                this.perfdata = ObjectHelper.mergeRecursive(this.perfdata, pd, {
                    // Special case: Merge the different runs
                    "payload": (o1, o2) => {
                        let ret = o1;
                        
                        for(let i = 0; i < o2.length; ++i) {
                            for(let j = 0; j < ret[i].data.length; ++j) {
                                ObjectHelper.assert("Same node", ret[i].data[j].supernode == o2[i].data[j].supernode);
                                ret[i].data[j] = ObjectHelper.mergeRecursive(ret[i].data[j], o2[i].data[j], {
                                    // Special case: Merge Supersections
                                    "sections": (o1, o2) => {
                                    let ret = o1;
                                    for(let i = 0; i < ret.length; ++i) {
                                        let b_found = false;
                                        for(let j = 0; j < o2.length; ++j) {
                                            if(ret[i].entry_node == o2[j].entry_node && ret[i].entry_core == o2[j].entry_core) {
                                                b_found = true;
                                                ObjectHelper.assert("Same node", ret[i].entry_node == o2[j].entry_node);
                                                ObjectHelper.assert("Same core", ret[i].entry_core == o2[j].entry_core);
                                                
                                                ret[i] = ObjectHelper.mergeRecursive(ret[i], o2[j], {
                                                    // Special case: Merge Sections
                                                    "entries": (o1, o2) => {
                                                        let ret = o1;

                                                        for(let i = 0; i < ret.length; ++i) {
                                                            let vi = ret[i];
                                                            let b_found = false;
                                                            for(let j = 0; j < o2.length; ++j) {
                                                                let vj = o2[j];

                                                                if(vi.flags == vj.flags && vi.node == vj.node && vi.iteration == vj.iteration && vi.thread == vj.thread) {
                                                                    ret[i] = ObjectHelper.mergeRecursive(ret[i], vj);
                                                                    b_found = true;
                                                                }
                                                            }
                                                        }

                                                        return ret;
                                                    }
                                                });
                                            }
                                        }
                                        ObjectHelper.assert("found", b_found);
                                    }
                                    return ret;
                                }});
                            }
                        }
                        return ret;
                    },
                });

                this.perfdata_mode[mode] = "avail";
                console.log("Got new mode " + mode);
            }
            
            clearPerfData() { 
                this.perfdata = null;
                this.perfdata_mode = {}; 
                this.brackets = {}; 
            }
            addHighlight(hl) {
                this.highlights.push(hl);
            }
            clearHighlights() {
                this.highlights = [];
            }

            setGraph(stateid, g) { this.state_graphs[stateid] = g; }

            setTopLevelGraph(g) { ObjectHelper.assert("g valid", g != null); this.top_level_graph = g; }

            nodeid(unified) {
                return unified & 0xFFFF;
            }

            // Passed through from graph
            node(stateid, nodeid) {
                return this.state_graphs[stateid].node(this.nodeid(nodeid));
            }

            addBracket(b, stateid, nodeid) {
                if(nodeid == undefined) nodeid = 0;
                stateid = new Number(stateid);
                nodeid = new Number(nodeid);
                let unified_id = (stateid << 16) | nodeid;

                let ks = ObjectHelper.listKeys(this.brackets);
                if(ks.includes(unified_id.toString())) {
                    this.canvas_manager.removeDrawable(this.brackets[unified_id]);
                    this.brackets[unified_id].destroy();
                }
                this.brackets[unified_id] = b;
            }

            drawSDFG() {
                let g = this.top_level_graph;
                if(g == null) return; // Nothing to draw (yet)
                paint_sdfg(g, this.sdfg, new DrawNodeState(this.ctx, -1));

                // Draw what is inside the state boxes, offset by the top 
                // left corner of the state box
                this.sdfg.nodes.forEach(state => {
                    let state_x_offs = g.node(state.id).x - g.node(state.id).width / 2.0;
                    let state_y_offs = g.node(state.id).y - g.node(state.id).height / 2.0;
                    let ctx = this.ctx;
                    ctx.fillText(state.id, state_x_offs+1.0*LINEHEIGHT, state_y_offs+1.0*LINEHEIGHT);
                    let state_g = null;
                    if(cache_graphs && (state.id in this.graphcache)) {
                        state_g = this.graphcache[state.id];
                    }
                    else {
                        if (state.attributes.collapsed == true) {
                            state_g = new dagre.graphlib.Graph();
                            g.setGraph({});
                            g.setDefaultEdgeLabel(function (u, v) { return {}; });
                            dagre.layout(g);
                        }
                        else {
                            state_g = layout_state(state.attributes);
                            addXYOffset(state_g, state_x_offs + 2*LINEHEIGHT, state_y_offs+2*LINEHEIGHT);
                            this.graphcache[state.id] = state_g;
                        }

                    }
                    
                    paint_state(state_g, new DrawNodeState(ctx, state.id));
                });
            }

            async createBracket(ctx, stateid, nodeid) {
                "use strict";

                let global_measurement = stateid == 0xFFFF || stateid == 65535;
                let k = nodeid;
                let b = new Bracket(ctx);
                global_state.addBracket(b, stateid, nodeid);

                let sections = this.defaultRun();
                let targetsection = null;
                // Only selects one single section!
                await sections.wait_ready();
                for(let section of sections) {
                    let clsec = section.realize();
                    ObjectHelper.assert("correct type", this.perfdataIsLazy() || (clsec instanceof SuperSection));
                    
                    let tmp = null;
                    if(clsec instanceof LazySuperSection) tmp = await clsec.containsSection(k, stateid);
                    else tmp = clsec.containsSection(k, stateid);
                    if(tmp) {
                        let tmp = null;
                        if(clsec instanceof LazySuperSection) 
                            tmp = await clsec.toSection(k, stateid);
                        else
                            tmp = clsec.toSection(k, stateid);

                        targetsection = await ObjectHelper.valueFromPromise(tmp);
                        
                        if(targetsection === undefined) continue;
                        break; 
                    }
                }
                if(global_measurement) {
                    let clsec = sections.elem(0).realize();
                    let t1 = await ObjectHelper.valueFromPromiseFull(clsec.sections());
                    ObjectHelper.assert("Correct type", t1 instanceof Array);
                    ObjectHelper.assert("Correct len", t1.length == 1);
                    targetsection = t1[0];
                    ObjectHelper.logObject("targetsection", targetsection);

                    // Set the overhead numbers
                    this.performance_references["overhead_numbers"] = this.perfdata.overhead_numbers;
                }

                if(targetsection == null) {
                    console.log("Failed to obtain a valid section!");
                    if(targetsection_ignore_error) return undefined; 
                }
                ObjectHelper.assert("targetsection valid", targetsection != null);
                
                let path_analysis = AutoCriticalPathAnalysis(this.communicator, this.perfdata.payload, k, stateid).analyze();
                
                // Same thing as above, now for multiple runs.
                let t_atd1 = sections.map(x => x.realize().toSection(k, stateid));
                t_atd1 = await ObjectHelper.waitArray(t_atd1);
                let all_threads_data = t_atd1.filter(x => x != undefined && (x._entries != undefined || x.communicator != undefined)).map(x => AutoThreadAnalysis(this.communicator, x).analyze());
                let t_atd2 = await ObjectHelper.waitArray(all_threads_data);
                let all_analyses = new DataBlock(t_atd2, "all_threads");

                path_analysis = await ObjectHelper.valueFromPromise(path_analysis);

                if(this.perfdata.default_depth == -1 && this.perfdata.mode == "default") {
                    // Reference (no inner instrumentation, only the whole frame).
                    this.performance_references["critical_paths"] = path_analysis.data.critical_paths;
                }
                else {
                    // Normal mode (nodes, not global)
                }


                let targetsection_analysis = AutoThreadAnalysis(this.communicator, targetsection).analyze();
                targetsection_analysis = await ObjectHelper.valueFromPromise(targetsection_analysis);
                
                // Get repetitions (we'll need this later)
                let repquery = this.communicator.getRepetitions().get();
                let repcount =  await ObjectHelper.valueFromPromise(repquery);
                
                all_analyses.repcount = repcount;

                let but1 = new ParallelizationButton(ctx, targetsection_analysis, all_analyses, path_analysis, this.communicator);
                b.addButton(but1);

                let supersections = sections.map(x => x.realize());

                let memsubsel = undefined;
                if(global_measurement) {
                    memsubsel = supersections.map(x => x.sections()).filter(x => x != undefined);
                }
                else {
                    memsubsel = supersections.map(x => x.getSections(k, stateid));
                    for(let i = 0; i < memsubsel.length; ++i) {
                        memsubsel[i] = await ObjectHelper.valueFromPromise(memsubsel[i]);
                    }
                    memsubsel = memsubsel.filter(x => x != undefined);
                }
                memsubsel = ObjectHelper.flatten(memsubsel);
                
                // Legacy
                //let all_mem_analyses = new DataBlock(memsubsel.map(x => new MemoryAnalysis(new Section(x)).analyze()).filter(x => x != undefined), "all_thread_mem");
                
                let tmp_ssama = sections.map(x => AutoSuperSectionMemoryAnalysis(this.communicator, x.realize(), k, stateid, global_state.target_memory_speed).analyze());
                tmp_ssama = await tmp_ssama;
                let supersection_all_mem_analyses = new DataBlock(tmp_ssama.filter(x => x != null), "all_thread_mem");

                
                let all_mem_analyses = supersection_all_mem_analyses;
                for(let i = 0; i < all_mem_analyses.data.length; ++i) {
                    all_mem_analyses.data[i] = await ObjectHelper.valueFromPromise(all_mem_analyses.data[i]);
                }
                all_mem_analyses.data = all_mem_analyses.data.filter(x => x != null);
                all_mem_analyses.repcount = repcount;

                let but2 = new MemoryButton(ctx, all_mem_analyses, global_state.target_memory_speed);
                b.addButton(but2);


                but1.setOnDoubleClick(p => {
                    let newwin = new DiodeWindow(window);
                    newwin.setSenderData({ 
                        className: "ParallelizationButton",
                        dataParams: but1.dataparams
                    });
                    let subwin = newwin.open("subwindow.html", "_blank");
                    if(!subwin) {
                        console.log("Failed to open subwindow");
                        alert("failed to open subwindow");
                    }
                    
                    return true;
                });
                but2.setOnDoubleClick(p => {
                    let newwin = new DiodeWindow(window);
                    newwin.setSenderData({ 
                        className: "MemoryButton",
                        dataParams: but2.dataparams
                    });
                    let subwin = newwin.open("subwindow.html", "_blank");
                    if(!subwin) {
                        console.log("Failed to open subwindow");
                        alert("failed to open subwindow");
                    }
                    
                    return true;
                });


                if(ObjectHelper.listKeys(this.perfdata_mode).includes("all")) {
                    let waited_data = sections.map(x => AutoSuperSectionVectorizationAnalysis(this.communicator, x.realize(), k, stateid, path_analysis));
                    
                    for(let i = 0; i < waited_data.length; ++i) {
                        let tmp = waited_data[i].analyze();
                        tmp = await tmp;
                        waited_data[i] = tmp;
                        if(waited_data[i] != undefined)
                            waited_data[i] = await ObjectHelper.valueFromPromiseFull(waited_data[i]);
                    }

                    let supersection_all_vec_analyses = new DataBlock(waited_data.filter(x => x != null && x !== undefined), "all_thread_vec");
                    supersection_all_vec_analyses.repcount = repcount;
                    let but4 = new VectorizationButton(ctx, supersection_all_vec_analyses);
                    b.addButton(but4);

                    but4.setOnDoubleClick(p => {
                        let newwin = new DiodeWindow(window);
                        newwin.setSenderData({ 
                            className: "VectorizationButton",
                            dataParams: but4.dataparams
                        });
                        let subwin = newwin.open("subwindow.html", "_blank");
                        if(!subwin) {
                            console.log("Failed to open subwindow");
                            alert("failed to open subwindow");
                        }
                        
                        return true;
                    });
                }
                if(ObjectHelper.listKeys(this.perfdata_mode).includes("all")) {
                    let waited_data = sections.map(x => AutoSuperSectionCacheOpAnalysis(this.communicator, x.realize(), k, stateid, path_analysis));
                    
                    for(let i = 0; i < waited_data.length; ++i) {
                        let tmp = waited_data[i].analyze();
                        tmp = await tmp;
                        waited_data[i] = tmp;
                        if(waited_data[i] != undefined)
                            waited_data[i] = await ObjectHelper.valueFromPromiseFull(waited_data[i]);
                    }

                    let supersection_all_vec_analyses = new DataBlock(waited_data.filter(x => x != null && x !== undefined), "all_thread_cacheop");
                    supersection_all_vec_analyses.repcount = repcount;
                    let but4 = new CacheOpButton(ctx, supersection_all_vec_analyses);

                    but4.setOnDoubleClick(p => {
                        let newwin = new DiodeWindow(window);
                        newwin.setSenderData({ 
                            className: "CacheOpButton",
                            dataParams: but4.dataparams
                        });
                        let subwin = newwin.open("subwindow.html", "_blank");
                        if(!subwin) {
                            console.log("Failed to open subwindow");
                            alert("failed to open subwindow");
                        }
                        
                        return true;
                    });

                    b.addButton(but4);
                }
                if(ObjectHelper.listKeys(this.perfdata_mode).includes("all")) {
                    let waited_data = sections.map(x => AutoSuperSectionMemoryOpAnalysis(this.communicator, x.realize(), k, stateid, path_analysis));
                    
                    for(let i = 0; i < waited_data.length; ++i) {
                        let tmp = waited_data[i].analyze();
                        tmp = await tmp;
                        waited_data[i] = tmp;
                        if(waited_data[i] != undefined)
                            waited_data[i] = await ObjectHelper.valueFromPromiseFull(waited_data[i]);
                    }

                    let supersection_all_vec_analyses = new DataBlock(waited_data.filter(x => x != null && x !== undefined), "all_thread_memop");
                    supersection_all_vec_analyses.repcount = repcount;
                    let but4 = new MemoryOpButton(ctx, supersection_all_vec_analyses);

                    but4.setOnDoubleClick(p => {
                        let newwin = new DiodeWindow(window);
                        newwin.setSenderData({ 
                            className: "MemoryOpButton",
                            dataParams: but4.dataparams
                        });
                        let subwin = newwin.open("subwindow.html", "_blank");
                        if(!subwin) {
                            console.log("Failed to open subwindow");
                            alert("failed to open subwindow");
                        }
                        
                        return true;
                    });

                    b.addButton(but4);
                }


                b.setupEventListeners();

                return b;
            }

            // drawPerfInfo for all states
            async drawAllPerfInfo() {

                if(this.perfdata.overhead_percentage != undefined) {

                    if(max_func(this.perfdata.overhead_percentage, x => x) > max_overhead_percentage)
                    {
                        alert("Warning: Instrumentation overhead exceeded limit (" + max_overhead_percentage + ") at least once.\nPercentages: " + JSON.stringify(this.perfdata.overhead_percentage));
                    }
                }

                if(this.getPerformanceReferences("overhead_numbers") != undefined) {
                    let overhead = this.getPerformanceReferences("overhead_numbers");

                    if(auto_compensate_overhead) {
                        // Subtract the overhead numbers from all measurements
                        let affected_keys = ObjectHelper.listKeys(overhead);
                        for(let k of affected_keys) {
                            let v = overhead[k];
                            ObjectHelper.modifyingMapRecursive(this.perfdata.payload, k, x => {
                                if(Number(x) - Number(v) > 0) {
                                    console.log("Changing overhead...");
                                    return Number(x) - Number(v);
                                }
                                else {
                                    console.log("Error: Would underflow!");
                                    return 0;
                                }
                            });
                        }
                    }
                }

                let defaultRun = this.defaultRun();
                await defaultRun.wait_ready();
                let tmp = await ObjectHelper.valueFromPromise(defaultRun.allSectionStateIds());
                let states = ObjectHelper.flatten(tmp);
                states = MathHelper.unique(states);
                for(let x of states) {
                    if(x == 0xFFFF || x == 65535)
                    {
                        // This is the global state
                        let bb = calculateBoundingBox(this.top_level_graph);

                        let right = bb.width;
                        let top = 0;
                        let bot = bb.height;
                        
                        let b_tmp = this.createBracket(this.ctx, x, undefined);
                        let b = await b_tmp;
                        ObjectHelper.assert("Global measurement valid", b != undefined);

                        b.drawEx(new Pos(right, top), new Pos(right, bot), 50, 20, true, () => {});
                        this.canvas_manager.addDrawable(b);

                        continue;
                    }
                    await this.drawPerfInfo(x);
                }

                if(ObjectHelper.listKeys(this.perfdata_mode).includes("all")) {
                    if(this.request_download != "") {
                        // A download of all buttons was requested
                        
                        createImageDownload(this.brackets, this.request_download);
                        this.request_download = ""; // Clear
                    }
                }
            }

            // multistate-unaware!
            async drawPerfInfo(stateid) {
                let ctx = this.ctx;
                let scopedict = {};

                if(this.perfdata.type != "DataReady") {
                    let payload = this.perfdata.payload;

                    // Check correctness of data
                    let x = new ResultVerifier(payload);
                }

                // There are 2 types of nodes: Those that open a scope 
                // (MapEntry) and those that don't (the rest).
                // We search first for all section entry nodes.
                let tmp = await this.defaultRun().allSectionNodeIds(stateid);
                let all_entry_nodes = ObjectHelper.flatten(tmp);
                // Filter that down to uniques.
                all_entry_nodes = MathHelper.unique(all_entry_nodes);
                // For every entry node, we create an array.
                for(let tmp of all_entry_nodes) {
                    scopedict[tmp] = [];
                }
                // Add an extra one for the top-level
                scopedict[null] = [];


                for(let sdfgnode of this.sdfg.nodes) {
                    if(sdfgnode.id != stateid) continue;
                    for(let node of sdfgnode.attributes.nodes) {
                        let gnode = this.node(stateid, node.id);
                        if(gnode == undefined) {
                            console.log("Welp. How did this happen? (undefined gnode for (" + stateid + ", " + node.id + "))");
                        }
                        else {
                            let anchor_x = gnode.x + gnode.width / 2.;
                            let anchor_y = gnode.y - gnode.height / 2;

                            // We are only interested in scopes for now.
                            // Ordering scopes "upside down", because an 
                            // entry node is not marked as scope entry, but 
                            // nodes inside that scope have a link to the 
                            // starting node.
                            if(node.scope_entry != null) {
                                // This node has a scope entry. Add this node to the dict with the key of the entry node (reverse the mapping basically)
                                if(scopedict[node.scope_entry] == undefined) {
                                    scopedict[node.scope_entry] = [];
                                    console.log("Had to create an array for unknown entry node " + node.scope_entry);
                                }
                                scopedict[node.scope_entry].push(this.nodeid(node.id));
                            }
                        }
                    }
                }

                // Topologically sort scopes
                let sorted_array = [];
                {
                    let changed = true;
                    while(changed) {
                        changed = false;
                        
                        for(let key in scopedict) {
                            // Skip objects already taken
                            if(sorted_array.some(e => e == key)) continue; 


                            // For each array, check if the selected key is a dependency. If it is, check next (we are going outside -> inside)
                            let retry = false;
                            Object.keys(scopedict).forEach(e => {
                                if(scopedict[e].some(o => o == key && !sorted_array.some(x => x == e))) {
                                    retry = true;
                                }
                            });
                            if(retry) continue;
                            
                            // Otherwise, we'll have a change
                            changed = true;

                            // Add the key to the sorted array
                            sorted_array.push(key);
                        }

                    }
                }

                // Since we now have the sorted array, but in the wrong 
                // order, reverse it.
                let sa = sorted_array.reverse();

                // Draw the performance information for each node in the sorted list
                for(let k of sa) {
                    if(k == null) break;
                    if(k == "null") break;

                    if(!all_entry_nodes.map(x => x.toString()).includes(k.toString())) {
                        continue; // Skip nodes for which we don't have performance data.
                    }

                    // From the key, we can read the affected nodes
                    let affected = [];
                    affected.push(k);
                    let tmp = scopedict[k];
                    affected.push(...tmp);


                    // Now get the maximum and minimum y-positions
                    let top = min_func(affected, x => {

                        let gnode = this.node(stateid, x);

                        return gnode.y - gnode.height / 2;
                    });
                    let bot = max_func(affected, x => {
                        let gnode = this.node(stateid, x);

                        return gnode.y + gnode.height / 2;
                    });

                    // Now we just have to do the same for the right side :)
                    let right = max_func(affected, x => {
                        let gnode = this.node(stateid, x);

                        return gnode.x + gnode.width / 2;
                    });

                    this.createBracket(ctx, stateid, k).then(resval => {
                        if(resval === undefined) return;

                        resval.drawEx(new Pos(right, top), new Pos(right, bot), 50, 20, true, () => {});
                        this.canvas_manager.addDrawable(resval);
                    });
                    
                }
            }

        }

        function message_handler(msg) {
            let sdfg = JSON.parse(msg);
            if (sdfg.type == "SDFG") {
                global_state.clearPerfData();
                global_state.canvas_manager.clearDrawables();
                global_state.setSDFG(sdfg); // Set the sdfg to a global helper

                // Clear all brackets
                for(let x of Object.values(global_state.brackets)) {
                    x.destroy();
                }
                global_state.brackets = {};
                global_state.graphcache = {};
                global_state.canvas_manager.clearDrawables();
            }
            else if(sdfg.type == "PerfInfo") {
                global_state.setPerfData(sdfg);
                global_state.canvas_manager.clearDrawables();
                global_state.drawAllPerfInfo();
                return;
            }
            else if(sdfg.type == "DataReady") {

                // Do the same as when directly getting "PerfInfo" (as above), but data has to be requested lazily.
                global_state.setPerfData(sdfg);
                global_state.canvas_manager.clearDrawables();
                global_state.drawAllPerfInfo();
                return;
            }
            else if(sdfg.type == "fetcher") {
                // Lazy evaluation stuff.
                global_state.communicator.receive(sdfg);
                return;
            }
            else if(sdfg.type == "MemSpeed") {
                global_state.setTargetMemBandwidth(sdfg.payload);
                return;
            }
            else if(sdfg.type == "save-images") {
                global_state.request_download = sdfg.name;
                return;
            }
            else if(sdfg.type == "highlight-element") {
                let tmp = {
                    "state-id": sdfg['sdfg-id'],
                    "node-id": sdfg['node-id']
                };
                global_state.addHighlight(tmp);
                return;
            }
            else if(sdfg.type == "clear-highlights") {
                global_state.clearHighlights();
                return;
            }
            else {
                console.log("Expected to receive an SDFG, but I got " + msg);
                return;
            }

            

            // draw the state boxes
            let g = layout_sdfg(sdfg);
            let bb = calculateBoundingBox(g);
            let cnvs = document.getElementById("myCanvas");
            cnvs.width = Math.min(Math.max(bb.width + 1000, cnvs.width), 16384);
            cnvs.height = Math.min(Math.max(bb.height + 1000, cnvs.height), 16384);
            paint_sdfg(g, null, new DrawNodeState(global_state.ctx, -1));

            global_state.setTopLevelGraph(g);

            // draw what is inside the state boxes, offset by the top left corner of the state box
            sdfg.nodes.forEach(function (state) {
                let state_x_offs = g.node(state.id).x - g.node(state.id).width / 2.0;
                let state_y_offs = g.node(state.id).y - g.node(state.id).height / 2.0;
                let ctx = document.getElementById("myCanvas").getContext('2d');
                ctx.fillText(state.id, state_x_offs+1.0*LINEHEIGHT, state_y_offs+1.0*LINEHEIGHT);
                let state_g = layout_state(state.attributes);
                addXYOffset(state_g, state_x_offs + 2*LINEHEIGHT, state_y_offs+2*LINEHEIGHT);
                paint_state(state_g, new DrawNodeState(ctx, state.id));
                global_state.setGraph(state.id, state_g);
            });

        }

        function isWithinBB(x, y, layoutinfo) {
            if ((x > layoutinfo.x - layoutinfo.width/2.0) && 
                (x < layoutinfo.x + layoutinfo.width/2.0) &&
                (y > layoutinfo.y - layoutinfo.height/2.0) &&
                (y < layoutinfo.y + layoutinfo.height/2.0)) {
                    return true;
            }
            return false;
        }

        function addXYOffset(g, x_offs, y_offs) {
            "use strict";
            g.nodes().forEach(function (v) {
                g.node(v).x += x_offs;
                g.node(v).y += y_offs;
            });
            g.edges().forEach(function (e) {
                let edge = g.edge(e);
                edge.x += x_offs;
                edge.y += y_offs;
                edge.points.forEach(function (p) {
                    p.x += x_offs;
                    p.y += y_offs;
                }); 
            });
        }

        function paint_sdfg(g, sdfg, drawnodestate) {

            ObjectHelper.assert("drawnodestate must be defined", drawnodestate != undefined);

            let ctx = drawnodestate.ctx;

            g.nodes().forEach( v => {
                let topleft_x = g.node(v).x - g.node(v).width / 2.0;
                let topleft_y = g.node(v).y - g.node(v).height / 2.0;
                
                ctx.beginPath();
                ctx.moveTo(topleft_x, topleft_y);
                ctx.lineTo(topleft_x + g.node(v).width, topleft_y);
                ctx.lineTo(topleft_x + g.node(v).width, topleft_y+g.node(v).height);
                ctx.lineTo(topleft_x, topleft_y+g.node(v).height);
                ctx.lineTo(topleft_x, topleft_y);
                ctx.closePath();
                ctx.strokeStyle="blue";
                ctx.stroke();

            });
            g.edges().forEach(e => {
                drawnodestate.draw_edge(g.edge(e));
            });
        
        }

        function layout_sdfg(sdfg) {

            // layout the sdfg as a dagre graph
            let g = new dagre.graphlib.Graph();

            let ctx = global_state.ctx;

            // Set an object for the graph label
            g.setGraph({});

            // Default to assigning a new object as a label for each new edge.
            g.setDefaultEdgeLabel(function (u, v) { return {}; });

            // layout each state to get its size
            sdfg.nodes.forEach(function (state) {
                let stateinfo = {};
                stateinfo.label = state.id;
                if (state.attributes.collapsed == true) {
                    stateinfo.width = ctx.measureText(stateinfo.label).width;
                    stateinfo.height = LINEHEIGHT;
                } 
                else {
                    let state_g = layout_state(state.attributes);
                    stateinfo = calculateBoundingBox(state_g);
                }
                stateinfo.width += 4*LINEHEIGHT;
                stateinfo.height += 4*LINEHEIGHT;
                g.setNode(state.id, stateinfo);
            });

            sdfg.edges.forEach(function (edge) {
                let label = edge.attributes
                let ctx = document.getElementById("myCanvas").getContext('2d');
                let textmetrics = ctx.measureText(label);
                g.setEdge(edge.src, edge.dst, { name: label, label: label, height: LINEHEIGHT, width: textmetrics.width });
            });

            dagre.layout(g);

            // annotate the sdfg with its layout info
            sdfg.nodes.forEach(function (state) {
                let gnode = g.node(state.id);
                state.attributes.layout = {};
                state.attributes.layout.x = gnode.x;
                state.attributes.layout.y = gnode.y;
                state.attributes.layout.width = gnode.width;
                state.attributes.layout.height = gnode.height;
            });

            sdfg.edges.forEach(function (edge) {
                let gedge = g.edge(edge.src, edge.dst);
                edge.attributes = {};
                // FIXME: edge.attributes should be an object when we generate json SDFG in Python
                edge.attributes.label = gedge.label; 
                edge.attributes.layout = {};
                edge.attributes.layout.width = gedge.width;
                edge.attributes.layout.height = gedge.height;
                edge.attributes.layout.x = gedge.x;
                edge.attributes.layout.y = gedge.y;
                edge.attributes.layout.points = gedge.points;
            });

            return (g);

        }

        function layout_state(sdfg_state) {
            // layout the state as a dagre graph

            let g = new dagre.graphlib.Graph();

            // Set an object for the graph label
            g.setGraph({});

            // Default to assigning a new object as a label for each new edge.
            g.setDefaultEdgeLabel(function (u, v) { return {}; });

            // Add nodes to the graph. The first argument is the node id. The 
            // second is metadata about the node (label, width, height),
            // which will be updated by dagre.layout (will add x,y).

            sdfg_state.nodes.forEach(function (node) {
                let nodesize = calculateNodeSize(sdfg_state, node)
                node.attributes.layout = {}
                node.attributes.layout.width = nodesize.width;
                node.attributes.layout.height = nodesize.height;
                node.attributes.layout.label = node.attributes.label;
                node.attributes.layout.type = node.attributes.type;
                node.attributes.layout.in_connectors = node.attributes.in_connectors;
                node.attributes.layout.out_connectors = node.attributes.out_connectors;
                g.setNode(node.id, node.attributes.layout);
            });

            sdfg_state.edges.forEach(function (edge) {
                let label = edge.attributes.label
                let ctx = document.getElementById("myCanvas").getContext('2d');
                let textmetrics = ctx.measureText(label);
                g.setEdge(edge.src, edge.dst, { label: label, height: LINEHEIGHT, width: textmetrics.width });
            });

            dagre.layout(g);
            return g;
        }

        function calculateNodeSize(sdfg_state, node) {
            let ctx = document.getElementById("myCanvas").getContext('2d');
            let labelsize = ctx.measureText(node.attributes.label).width;
            let inconnsize = 0;
            let outconnsize = 0;
            node.attributes.in_connectors.forEach(function(conn) {
                // add 10px of margin around each connector
                inconnsize += ctx.measureText(conn).width + 10;
            });
            node.attributes.out_connectors.forEach(function(conn) {
                // add 10px of margin around each connector
                outconnsize += ctx.measureText(conn).width + 10;
            });
            let maxwidth = Math.max(labelsize, inconnsize, outconnsize);
            let maxheight = 2*LINEHEIGHT;
            if (node.attributes.in_connectors.length + node.attributes.out_connectors.length > 0) {
                maxheight += 4*LINEHEIGHT;
            }

            let size = { width: maxwidth, height: maxheight }

            // add something to the size based on the shape of the node
            if (node.attributes.type == "ArrayNode") {
                size.width += size.height;
            }
            else if (node.attributes.type == "MapEntry") {
                size.width += 2.0 * size.height;
            }
            else if (node.attributes.type == "MapExit") {
                size.width += 2.0 * size.height;
            }
            else if (node.attributes.type == "Tasklet") {
                size.width += 2.0 * (size.height / 3.0);
            }
            else if (node.attributes.type == "Reduce") {
                size.width *= 2;
                size.height = size.width / 3.0;
            }
            else {
            }

            return size
        }



        function calculateBoundingBox(g) {
            // iterate over all objects, calculate the size of the bounding box
            let bb = {};
            bb.width = 0;
            bb.height = 0;

            g.nodes().forEach(function (v) {
                let x = g.node(v).x + g.node(v).width / 2.0;
                let y = g.node(v).y + g.node(v).height / 2.0;
                if (x > bb.width) bb.width = x;
                if (y > bb.height) bb.height = y;
            });

            return bb;
        }

        

        function paint_state(g, drawnodestate) {
            g.nodes().forEach(function (v) {
                drawnodestate.draw_node(g.node(v), v);
            });
            g.edges().forEach(function (e) {
                let edge = g.edge(e);
                ObjectHelper.assert("edge invalid", edge);
                drawnodestate.draw_edge(g.edge(e));
            });
        }

    </script>
</body>

</html>